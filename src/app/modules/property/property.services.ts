import httpStatus from 'http-status';
import { Document, Types } from 'mongoose';
import config from '../../config';
import AppError from '../../error/appError';
import { sendAdminEmail, sendEmail } from '../../utils/sendEmail';
import { Booking } from '../booking/booking.model';
import { PropertyReview } from '../propertyReview/propertyReview.model';
import { Subscription } from '../subscription/subscription.model';
import { User } from '../user/user.model';
import { IProperty } from './property.interface';
import { Property } from './property.model';
import { emailVariable } from '../../utils/constantValue';

interface IPropertyDocument extends IProperty, Document { }

type Filters = {
  status?: string;
  where?: string;
  minPrice?: number;
  maxPrice?: number;
  propertyType?: string;
  availability?: string; 
  searchTerm?: string; 
};

const PROPERTY_TYPE_MAP: Record<string, string> = {
  'boys quatres': 'boys quarters',
  'girls quatres': 'girls quarters',
};

const createProperty = async (landlordId: string, propertyData: IProperty): Promise<IProperty> => {
  // Verify user and role
  const user = await User.findById(landlordId);
  if (!user || (user.role !== 'landlord' && user.role !== 'admin')) {
    throw new AppError(httpStatus.FORBIDDEN, 'Invalid landlord or admin');
  }

  // Check property limit based on subscription
  let propertyLimit = 2; // Default limit for no subscription
  const activeSubscription = await Subscription.findOne({
    landlord: landlordId,
    status: 'active',
  }).populate('package');

  if (activeSubscription && activeSubscription.package) {
    const packageData = activeSubscription.package as any;
    propertyLimit = packageData.propertyLimit;
  }

  // Count existing properties
  const existingProperties = await Property.countDocuments({ landlordId });
  if (existingProperties >= propertyLimit) {
    throw new AppError(
      httpStatus.FORBIDDEN,
      'Property limit reached. Please upgrade your plan to add more properties.'
    );
  }

  // Remove PID if provided, as it's generated by the schema
  delete (propertyData as any).PID;
  propertyData.landlordId = new Types.ObjectId(landlordId);
  const property = await Property.create(propertyData);

  // Send email to landlord
  await sendEmail(
    user.email,
    'Property Submission Received',
    `
      <div style="font-family: Arial, sans-serif; line-height: 1.6; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px;">
       ${emailVariable.headerLogo}
        <h2 style="color: #333; text-align: center;">Property Submission Received!</h2>
        <p style="color: #555;">Dear ${user.name},</p>
        <p style="color: #555;">Thank you for submitting your property "${property.headlineYourProperty || property.propertyType}" (PID: ${property.PID}) to our platform. We have received your submission, and it is currently under review by our admin team.</p>
        <p style="color: #555;">Once your property is reviewed, you will receive a confirmation email regarding its approval or rejection. If approved, your property will be activated and visible to tenants.</p>
        <p style="color: #555;">If you have any questions or need assistance, please feel free to contact our support team at <a href="mailto:${config.SUPPORT_EMAIL}" style="color: #007BFF;">${config.SUPPORT_EMAIL}</a>.</p>
        <p style="color: #555;">We look forward to helping you list your property!</p>
        <p style="color: #555;">Best regards,<br>${emailVariable.regards}</p>
         <hr style="border-top: 1px solid #e0e0e0; margin: 20px 0;">
          ${emailVariable.footer}
      </div>
    `
  );

  await sendAdminEmail(
    '',
  'New Property Submission Received',
  `
    <div style="font-family: Arial, sans-serif; line-height: 1.6; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px;">
      ${emailVariable.headerLogo}
      <h2 style="color: #333; text-align: center;">New Property Submission Received!</h2>
      <p style="color: #555;">Hello Admin,</p>
      <p style="color: #555;">A new property has been submitted to the platform by <strong>${user.name}</strong> (Email: ${user.email}).</p>
      
      <h3>Property Details:</h3>
      <ul style="color: #555;">
        <li><strong>Property Title:</strong> ${property.headlineYourProperty || property.propertyType}</li>
        <li><strong>Property ID (PID):</strong> ${property.PID}</li>
        <li><strong>Submitted On:</strong> ${new Date().toDateString()}</li>
      </ul>

      <p style="color: #555;">Please review the property submission and approve or reject it accordingly.</p>
      <p style="color: #555;">If you have any questions, contact the support team at <a href="mailto:${config.SUPPORT_EMAIL}" style="color: #007BFF;">${config.SUPPORT_EMAIL}</a>.</p>
      <p style="color: #555;">Regards,<br>${emailVariable.regards}</p>
      <hr style="border-top: 1px solid #e0e0e0; margin: 20px 0;">
      ${emailVariable.footer}
    </div>
  `
);

  return property;
};

// const createProperty = async (landlordId: string, propertyData: IProperty): Promise<IProperty> => {
//   const user = await User.findById(landlordId);
//   if (!user || user.role !== 'landlord') {
//     throw new AppError(httpStatus.FORBIDDEN, 'Invalid landlord');
//   }
//   // Remove PID if provided, as it's generated by the schema
//   delete (propertyData as any).PID;
//   propertyData.landlordId = new Types.ObjectId(landlordId);
//   const property = await Property.create(propertyData);
//   return property;
// };

const getProperties = async (filters: {
  status?: string;
  where?: string;
  minPrice?: number;
  maxPrice?: number;
  propertyType?: string;
  availability?: string;
  searchTerm?: string;
}, page: number = 1, limit: number = 10): Promise<{ properties: (IProperty & { reviews: any[] })[]; total: number }> => {
  const query: any = {};
  if (filters.status) {
    query.status = filters.status;
  }
  if (filters.searchTerm) {
    query.headlineYourProperty = { $regex: filters.searchTerm, $options: 'i' };
  }
  if (filters.where) {
    query.$or = [
      { 'location.address': { $regex: filters.where, $options: 'i' } },
      { 'location.state': { $regex: filters.where, $options: 'i' } },
      { 'location.city': { $regex: filters.where, $options: 'i' } },
      { 'location.town': { $regex: filters.where, $options: 'i' } },
      { 'location.area': { $regex: filters.where, $options: 'i' } },
    ];
  }
  if (filters.minPrice || filters.maxPrice) {
    query.rentPerYear = {};
    if (filters.minPrice) query.rentPerYear.$gte = filters.minPrice;
    if (filters.maxPrice) query.rentPerYear.$lte = filters.maxPrice;
  }
  if (filters.propertyType) {
    query.propertyType = filters.propertyType;
  }
  if (filters.availability) {
    query.formAvailable = { $lte: filters.availability };
  }

  const total = await Property.countDocuments(query);
  const properties = await Property.find(query)
    .sort({ createdAt: -1 })
    .skip((page - 1) * limit)
    .limit(limit)
    .populate('landlordId')
    .lean();


  const propertyIds = properties.map((p) => p._id);
  const reviews = await PropertyReview.find({ property: { $in: propertyIds } })
    .populate('user')
    .lean();

  const propertiesWithReviews = properties.map((property) => ({
    ...property,
    reviews: reviews.filter((review) => review.property.toString() === property._id.toString()),
  }));

  return { properties: propertiesWithReviews, total };
};


const getActiveProperties = async (
  filters: Filters,
  page: number = 1,
  limit: number = 10
): Promise<{
  properties: (IProperty & { reviews: any[] })[];
  total: number;
  minPriceRange: number | null;
  maxPriceRange: number | null;
}> => {
  const query: any = { isActive: true };

  // ---------------- STATUS ----------------
  if (filters.status) query.status = filters.status;

  // ---------------- PRICE RANGE ----------------
  if (typeof filters.minPrice === 'number' || typeof filters.maxPrice === 'number') {
    query.rentPerYear = {};
    if (typeof filters.minPrice === 'number') query.rentPerYear.$gte = filters.minPrice;
    if (typeof filters.maxPrice === 'number') query.rentPerYear.$lte = filters.maxPrice;
  }

  // ---------------- AVAILABILITY ----------------
if (filters.availability) {
  const availDate = new Date(filters.availability);
  if (!isNaN(availDate.getTime())) {
    const availStr = availDate.toISOString().split('T')[0]; // "YYYY-MM-DD"
    query.formAvailable = { $lte: availStr }; // less than or equal
  }
}



  // ---------------- PROPERTY TYPE ----------------
  if (filters.propertyType && filters.propertyType.trim()) {
    const search = filters.propertyType.trim();
    query.propertyType = { $regex: search, $options: 'i' }; // substring match, case-insensitive
  }

  // ---------------- WHERE / SEARCH TERM ----------------
  const normalizeInput = (input: string) =>
    input
      .toLowerCase()
      .replace(/[.,/\\|()[\]{}!@#$%^&*+=:?;'`"<>_-]/g, ' ')
      .trim();

  const addTokenFallback = (input: string) => {
    const tokens = normalizeInput(input)
      .split(/\s+/)
      .filter(Boolean);
    if (!tokens.length) return;
    query.$and = (query.$and || []).concat(
      tokens.map(tok => ({
        $or: [
          { 'location.address': { $regex: tok, $options: 'i' } },
          { 'location.state': { $regex: tok, $options: 'i' } },
          { 'location.city': { $regex: tok, $options: 'i' } },
          { 'location.town': { $regex: tok, $options: 'i' } },
          { 'location.area': { $regex: tok, $options: 'i' } },
          { headlineYourProperty: { $regex: tok, $options: 'i' } },
        ],
      }))
    );
  };

  if (filters.where) addTokenFallback(filters.where);
  if (filters.searchTerm) addTokenFallback(filters.searchTerm);

  // ---------------- COUNT & FETCH ----------------
  const total = await Property.countDocuments(query);

  const properties = await Property.find(query)
    .sort({ createdAt: -1 })
    .skip((page - 1) * limit)
    .limit(limit)
    .populate('landlordId')
    .lean();

  // ---------------- REVIEWS ----------------
  const propertyIds = properties.map((p: any) => p._id);
  const reviews = await PropertyReview.find({ property: { $in: propertyIds } })
    .populate('user')
    .lean();

  const propertiesWithReviews = properties.map((property: any) => ({
    ...property,
    reviews: reviews.filter(
      (review: any) => review.property.toString() === property._id.toString()
    ),
  }));

  // ---------------- MIN/MAX PRICE ----------------
  const prices = properties.map((p: any) => p.rentPerYear).filter((n: any) => typeof n === 'number');
  const minPriceRange = prices.length ? Math.min(...(prices as number[])) : null;
  const maxPriceRange = prices.length ? Math.max(...(prices as number[])) : null;

  return { properties: propertiesWithReviews, total, minPriceRange, maxPriceRange };
};



const getLandlordProperties = async (
  landlordId: string,
  filters: {
    status?: string;
    where?: string;
    minPrice?: number;
    maxPrice?: number;
    propertyType?: string;
    availability?: string;
    searchTerm?: string; // Added searchTerm filter
  },
  page: number = 1,
  limit: number = 10
): Promise<{ properties: IProperty[]; total: number }> => {
  const user = await User.findById(landlordId);
  if (!user || user.role !== 'landlord') {
    throw new AppError(httpStatus.FORBIDDEN, 'Invalid landlord');
  }

  const query: any = { landlordId: new Types.ObjectId(landlordId) };

  // Add searchTerm filter for headlineYourProperty
  if (filters.searchTerm) {
    query.headlineYourProperty = { $regex: filters.searchTerm, $options: 'i' };
  }

  if (filters.status) {
    query.status = filters.status;
  }
  if (filters.where) {
    query.$or = [
      { 'location.address': { $regex: filters.where, $options: 'i' } },
      { 'location.state': { $regex: filters.where, $options: 'i' } },
      { 'location.city': { $regex: filters.where, $options: 'i' } },
      { 'location.town': { $regex: filters.where, $options: 'i' } },
      { 'location.area': { $regex: filters.where, $options: 'i' } },
    ];
  }
  if (filters.minPrice || filters.maxPrice) {
    query.rentPerYear = {};
    if (filters.minPrice) query.rentPerYear.$gte = filters.minPrice;
    if (filters.maxPrice) query.rentPerYear.$lte = filters.maxPrice;
  }
  if (filters.propertyType) {
    query.propertyType = filters.propertyType;
  }
  if (filters.availability) {
    query.formAvailable = { $lte: filters.availability };
  }

  const total = await Property.countDocuments(query);
  const properties = await Property.find(query)
    .sort({ createdAt: -1 })
    .skip((page - 1) * limit)
    .limit(limit)
    .populate('landlordId');
  return { properties, total };
};

const getSingleProperty = async (id: string): Promise<IProperty | null> => {
  // Fetch property with populated landlordId
  const property = await Property.findById(id).populate('landlordId');
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }

  // Fetch booking for the property with populated tenantId
  const booking = await Booking.findOne({ propertyId: id, isActive: true }).populate('tenantId');

  // Prepare the response by attaching tenant info (or null if no booking)
  const result = {
    ...property.toObject(),
    tenant: booking ? booking.tenantId : null,
  };

  return result;
};

const getPropertyWithReviews = async (id: string): Promise<IProperty & { reviews: any[] }> => {
  const property = await Property.findById(id).populate('landlordId');
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  const reviews = await PropertyReview.find({ property: id }).populate('user');
  return { ...property.toObject(), reviews };
};

const updateProperty = async (id: string, userId: string, userRole: string, updatedData: Partial<IProperty>): Promise<IProperty | null> => {
  const property = await Property.findById(id);
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  // if (userRole !== 'admin' && (property.landlordId && property?.landlordId.toString() !== userId)) {
  //   throw new AppError(httpStatus.FORBIDDEN, 'Unauthorized to update this property');
  // }
  const updatedProperty = await Property.findByIdAndUpdate(id, updatedData, {
    new: true,
    runValidators: true,
  }).populate('landlordId');
  return updatedProperty;
};

const updatePropertyStatus = async (id: string, status: IProperty['status']): Promise<IProperty | null> => {
  const property = await Property.findById(id);
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  const updatedProperty = await Property.findByIdAndUpdate(id, { status }, {
    new: true,
    runValidators: true,
  }).populate('landlordId');
  return updatedProperty;
};

const acceptOrRejectProperty = async (id: string, isActive: boolean): Promise<IProperty | null> => {
  const property = await Property.findById(id).populate('landlordId');
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }

  const updatedProperty = await Property.findByIdAndUpdate(
    id,
    { isActive },
    {
      new: true,
      runValidators: true,
    }
  ).populate('landlordId');

  // Send email only when landlord exists
  if (updatedProperty?.landlordId) {
    const landlord = await User.findById(updatedProperty.landlordId);
    if (landlord) {
      if (isActive) {
        // ✅ APPROVED EMAIL
        await sendEmail(
          landlord.email,
          'Property Approved',
          `
          <div style="font-family: Arial, sans-serif; line-height: 1.6; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px;">
            ${emailVariable.headerLogo}
            <h2 style="color: #28a745; text-align: center;">Property Approved!</h2>
            <p style="color: #555;">Dear ${landlord.name},</p>
            <p style="color: #555;">Your property "<strong>${updatedProperty.headlineYourProperty || updatedProperty.propertyType}</strong>" (PID: ${updatedProperty.PID}) has been <strong>approved</strong> and is now active on our platform.</p>
            <p style="color: #555;">You can manage your property through your landlord dashboard.</p>
            <p style="color: #555;">Need help? Contact <a href="mailto:${config.SUPPORT_EMAIL}" style="color: #007BFF;">${config.SUPPORT_EMAIL}</a>.</p>
            <p style="color: #555;">Best regards,<br>${emailVariable.regards}</p>
            <hr style="border-top: 1px solid #e0e0e0; margin: 20px 0;">
            ${emailVariable.footer}
          </div>
          `
        );
      } else {
        // ❌ REJECTED EMAIL
        await sendEmail(
          landlord.email,
          'Property Rejected',
          `
          <div style="font-family: Arial, sans-serif; line-height: 1.6; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px;">
            ${emailVariable.headerLogo}
            <h2 style="color: #dc3545; text-align: center;">Property Rejected</h2>
            <p style="color: #555;">Dear ${landlord.name},</p>
            <p style="color: #555;">We regret to inform you that your property "<strong>${updatedProperty.headlineYourProperty || updatedProperty.propertyType}</strong>" (PID: ${updatedProperty.PID}) has been <strong>rejected</strong> and is not listed on our platform at this time.</p>
            <p style="color: #555;">If you believe this is a mistake or would like to re-submit your property, please contact our support team.</p>
            <p style="color: #555;">Need help? Contact <a href="mailto:${config.SUPPORT_EMAIL}" style="color: #007BFF;">${config.SUPPORT_EMAIL}</a>.</p>
            <p style="color: #555;">Best regards,<br>${emailVariable.regards}</p>
            <hr style="border-top: 1px solid #e0e0e0; margin: 20px 0;">
            ${emailVariable.footer}
          </div>
          `
        );
      }
    }
  }

  return updatedProperty;
};



const rejectProperty = async (id: string): Promise<IProperty | null> => {
  const property = await Property.findById(id).populate('landlordId');
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  const updatedProperty = await Property.findByIdAndUpdate(id, { isActive: false }, {
    new: true,
    runValidators: true,
  }).populate('landlordId');

  // Send rejection email to landlord
  if (updatedProperty && updatedProperty.landlordId) {
    const landlord = await User.findById(updatedProperty.landlordId);
    if (landlord) {
      await sendEmail(
        landlord.email,
        'Property Submission Update',
        `
          <div style="font-family: Arial, sans-serif; line-height: 1.6; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px;">
           ${emailVariable.headerLogo}
            <h2 style="color: #333; text-align: center;">Property Submission Update</h2>
            <p style="color: #555;">Dear ${landlord.name},</p>
            <p style="color: #555;">Thank you for submitting your property "${updatedProperty.headlineYourProperty || updatedProperty.propertyType}" (PID: ${updatedProperty.PID}) to our platform.</p>
            <p style="color: #555;">After review, your property submission has not been approved at this time. Please review our guidelines or contact our support team for more details.</p>
            <p style="color: #555;">If you have any questions or need assistance, please feel free to contact our support team at <a href="mailto:${config.SUPPORT_EMAIL}" style="color: #007BFF;">${config.SUPPORT_EMAIL}</a>.</p>
            <p style="color: #555;">We look forward to assisting you further!</p>
            <p style="color: #555;">Best regards,<br>${emailVariable.regards}</p>
             <hr style="border-top: 1px solid #e0e0e0; margin: 20px 0;">
          ${emailVariable.footer}
        </div>
      `
      );
    }
  }

  return updatedProperty;
};

const deleteProperty = async (id: string, userId: string, userRole: string): Promise<IProperty | null> => {
  const property = await Property.findById(id);
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  // if (userRole !== 'admin' && property.landlordId.toString() !== userId) {
  //   throw new AppError(httpStatus.FORBIDDEN, 'Unauthorized to delete this property');
  // }
  const deletedProperty = await Property.findByIdAndDelete(id).populate('landlordId');
  return deletedProperty;
};

const updateHomePageViewStatus = async (propertyId: string): Promise<IProperty | null> => {
  const property = await Property.findById(propertyId);
  if (!property) {
    throw new AppError(httpStatus.NOT_FOUND, 'Property not found');
  }
  const updatedProperty = await Property.findByIdAndUpdate(propertyId, { isHomePageView: !property.isHomePageView }, { new: true });
  return updatedProperty;
};

export const PropertyService = {
  createProperty,
  getProperties,
  getActiveProperties,
  getLandlordProperties,
  getSingleProperty,
  getPropertyWithReviews,
  updateProperty,
  updatePropertyStatus,
  deleteProperty,
  acceptOrRejectProperty,
  rejectProperty,
  updateHomePageViewStatus
};